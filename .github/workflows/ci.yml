# =============================================================================
# CI - Text Replacement Extension
# =============================================================================
# Runs on every push and pull request to verify:
#   1. The build script succeeds for both Chromium and Firefox targets.
#   2. Both manifests are valid JSON with the correct manifest_version.
#   3. All source files referenced in the manifests actually exist.
#   4. No external URLs are loaded (privacy/security check).
#   5. The Content Security Policy does not include 'unsafe-inline'.
#   6. Source files are identical across browser builds.
# =============================================================================

name: CI

on:
  push:
    branches: [main, master]
  pull_request:
    branches: [main, master]

jobs:
  build:
    name: Build & Validate
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Run build script
        run: |
          chmod +x build.sh
          ./build.sh
          echo "Build completed successfully."

      - name: Validate manifests
        run: |
          echo "Validating manifests..."
          python3 << 'PYEOF'
          import json, sys

          errors = []

          # --- Chromium ---
          with open("dist/chromium/manifest.json") as f:
              cm = json.load(f)
          if cm["manifest_version"] != 3:
              errors.append(f"Chromium manifest_version is {cm['manifest_version']}, expected 3")
          else:
              print(f"  Chromium: valid (MV{cm['manifest_version']})")

          # --- Firefox ---
          with open("dist/firefox/manifest.json") as f:
              fm = json.load(f)
          if fm["manifest_version"] != 3:
              errors.append(f"Firefox manifest_version is {fm['manifest_version']}, expected 3")
          if "browser_specific_settings" not in fm:
              errors.append("Firefox manifest missing browser_specific_settings")
          elif "gecko" not in fm["browser_specific_settings"]:
              errors.append("Firefox manifest missing gecko settings")
          else:
              gecko_id = fm["browser_specific_settings"]["gecko"]["id"]
              print(f"  Firefox:  valid (MV{fm['manifest_version']}, gecko ID: {gecko_id})")

          if errors:
              for e in errors:
                  print(f"ERROR: {e}")
              sys.exit(1)

          print("Manifest validation passed.")
          PYEOF

      - name: Verify all referenced files exist
        run: |
          echo "Checking referenced files..."
          python3 << 'PYEOF'
          import json, os, sys

          errors = []
          for target in ["chromium", "firefox"]:
              d = f"dist/{target}"
              with open(f"{d}/manifest.json") as f:
                  m = json.load(f)

              # Background scripts
              bg = m.get("background", {})
              for f_name in bg.get("scripts", []):
                  if not os.path.isfile(f"{d}/{f_name}"):
                      errors.append(f"{target}: missing background script {f_name}")
              sw = bg.get("service_worker")
              if sw and not os.path.isfile(f"{d}/{sw}"):
                  errors.append(f"{target}: missing service worker {sw}")

              # Content scripts
              for cs in m.get("content_scripts", []):
                  for f_name in cs.get("js", []):
                      if not os.path.isfile(f"{d}/{f_name}"):
                          errors.append(f"{target}: missing content script {f_name}")

              # Icons
              for size, path in m.get("icons", {}).items():
                  if not os.path.isfile(f"{d}/{path}"):
                      errors.append(f"{target}: missing icon {path}")

              print(f"  {target}: all referenced files exist.")

          if errors:
              for e in errors:
                  print(f"ERROR: {e}")
              sys.exit(1)

          print("File reference check passed.")
          PYEOF

      - name: Security - no external URLs in source
        run: |
          echo "Checking for external URL references in source files..."
          python3 << 'PYEOF'
          import re, os, sys, glob

          # Scan source files for external URLs outside of comments.
          # Handles both single-line and multi-line comment styles:
          #   1. Track /* ... */ block comments across multiple lines
          #   2. Strip // single-line comments from JS
          #   3. Strip <!-- ... --> HTML comments (single-line)
          #   4. Strip remaining single-line /* ... */ fragments
          #   5. Search the remaining code for http:// or https:// URLs
          # This avoids false positives from URLs in documentation comments
          # while catching any URL that would actually execute at runtime.

          url_pattern = re.compile(r'https?://[a-zA-Z]')
          # Patterns for single-line comment removal (applied AFTER block comment tracking)
          comment_patterns = [
              # JS single-line comments: matches // but NOT :// (URL protocol).
              # Without the lookbehind, "https://evil.com" would have "//evil.com"
              # stripped as a "comment", hiding the URL from the scanner entirely.
              re.compile(r'(?<!:)//.*$'),
              re.compile(r'/\*.*?\*/'),        # JS/CSS block comments (single-line)
              re.compile(r'<!--.*?-->'),       # HTML comments (single-line)
          ]

          found = []
          for filepath in glob.glob('src/**/*', recursive=True):
              if not os.path.isfile(filepath):
                  continue
              if not filepath.endswith(('.js', '.html', '.css')):
                  continue

              in_block_comment = False
              with open(filepath) as f:
                  for lineno, line in enumerate(f, 1):
                      stripped = line

                      # Handle multi-line /* ... */ block comments.
                      # These span across lines, so we track state between lines.
                      if in_block_comment:
                          # We're inside a block comment — look for the closing */
                          close_idx = stripped.find('*/')
                          if close_idx == -1:
                              continue  # Entire line is inside the block comment
                          # Block comment ends on this line — keep only the part after */
                          stripped = stripped[close_idx + 2:]
                          in_block_comment = False

                      # Check for block comment openings on this line.
                      # A line like: code /* comment */ more code /* start...
                      # may have multiple /* tokens. We process left-to-right.
                      while '/*' in stripped:
                          open_idx = stripped.find('/*')
                          close_idx = stripped.find('*/', open_idx + 2)
                          if close_idx != -1:
                              # Block comment opens and closes on same line — remove it
                              stripped = stripped[:open_idx] + stripped[close_idx + 2:]
                          else:
                              # Block comment opens but doesn't close — rest of line is comment
                              stripped = stripped[:open_idx]
                              in_block_comment = True
                              break

                      # Strip single-line comments (// and <!-- -->)
                      for cp in comment_patterns:
                          stripped = cp.sub('', stripped)

                      if url_pattern.search(stripped):
                          found.append(f"  {filepath}:{lineno}: {line.rstrip()}")

          if found:
              print("ERROR: External URLs found in non-comment source code:")
              for f in found:
                  print(f)
              print("\nAll resources must be bundled locally. See Transparency & Safety in README.")
              sys.exit(1)
          else:
              print("No external URLs found in source code.")
          PYEOF

      - name: Security - verify strict CSP
        run: |
          echo "Checking Content Security Policy..."
          python3 << 'PYEOF'
          import json, sys

          errors = []
          for target in ["chromium", "firefox"]:
              with open(f"dist/{target}/manifest.json") as f:
                  m = json.load(f)
              csp_obj = m.get("content_security_policy", {})
              if isinstance(csp_obj, dict):
                  csp = csp_obj.get("extension_pages", "")
              else:
                  csp = str(csp_obj)

              # Parse CSP directives properly instead of checking substrings
              # on the full string. The old approach ("unsafe-inline" in csp and
              # "script-src" in csp) would false-positive when unsafe-inline
              # appeared in a DIFFERENT directive (e.g., style-src) but script-src
              # was also present. Splitting by ";" and checking each directive
              # independently prevents cross-directive confusion.
              directives = {}
              for part in csp.split(";"):
                  tokens = part.strip().split()
                  if tokens:
                      directives[tokens[0]] = tokens[1:]

              if "'unsafe-inline'" in directives.get("script-src", []):
                  errors.append(f"{target} CSP allows unsafe-inline for scripts!")
              if "'unsafe-inline'" in directives.get("style-src", []):
                  errors.append(f"{target} CSP allows unsafe-inline for styles!")
              print(f"  {target} CSP: {csp}")

          if errors:
              for e in errors:
                  print(f"ERROR: {e}")
              sys.exit(1)

          print("CSP checks passed.")
          PYEOF

      - name: Verify builds are identical except manifests
        run: |
          echo "Verifying source files are identical across builds..."
          ERRORS=0
          for file in background.js content.js manage.js manage.html manage.css; do
            if ! diff -q "dist/chromium/$file" "dist/firefox/$file" > /dev/null 2>&1; then
              echo "ERROR: $file differs between chromium and firefox builds!"
              ERRORS=$((ERRORS + 1))
            fi
          done
          if [ $ERRORS -gt 0 ]; then
            echo "FAILED: Source files should be identical across builds."
            exit 1
          fi
          echo "All shared source files are identical across builds."
